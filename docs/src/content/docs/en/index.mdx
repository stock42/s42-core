---
title: Welcome to S42-Core v2.0
description: s42-core is a powerful and flexible library built on Bun.js, designed to simplify the development of applications, especially those using microservices and cell-based architectures. This library supports the creation of modular and reusable software components and streamlines the implementation of high-performance monorepos.
template: splash
hero:
  title: |
    Welcome to <span class="text-orange-700">S</span><span class="text-blue-400">4</span><span class="text-green-500">2</span>-
    <span
      class="font-black text-transparent
        bg-clip-text bg-gradient-to-b
        from-gray-900 to-gray-400
        dark:from-gray-900 dark:to-gray-400"
    >
      Core
    </span>
  tagline: Start building the next generation of backend solutions with s42-core! Modular, scalable, and optimized for modern architectures, s42-core is your ultimate toolkit for backend development.
  image:
    file: ../../../assets/s42-core.png
  actions:
    - text: Guides
      link: /en/guides/example
      icon: right-arrow
      variant: primary
    - text: Documentation
      link: /en/reference
      icon: external
---


import { Card, CardGrid } from '@astrojs/starlight/components';

# What is s42-core?
## Introduction
s42-core is a robust and flexible Bun.js library designed to simplify the development of modern, scalable, and modular applications. Built with performance and developer productivity in mind, s42-core is particularly well-suited for microservices and cell-based architectures. It empowers developers to create high-performance solutions that are easy to maintain, update, and scale.

## Key Features

### Microservices and Cell-Based Architectures
s42-core provides out-of-the-box support for microservices and cell-based architectures. It enables developers to build modular applications where each microservice or cell can operate independently while communicating seamlessly. This design promotes better scalability and maintainability.

### Framework Agnostic
Unlike many libraries, s42-core does not lock you into a specific framework. You can integrate it with any framework or even use it standalone. Whether you are working with Bun.js, Express, Fastify, or Nest.js, s42-core fits seamlessly into your existing tech stack, allowing gradual adoption.

### Optimized for Bun.js
As a library built specifically for Bun.js, s42-core takes full advantage of Bun’s performance capabilities. This results in faster application execution, reduced startup times, and lower resource consumption.

### High Performance
Applications built with s42-core are optimized for demanding environments. It employs efficient patterns and practices, ensuring smooth and responsive performance even under heavy workloads.

### Simplified Monorepo Management
s42-core promotes modularity by facilitating the development of small, reusable software components (atoms). This makes it easier to manage and scale monorepos, as code can be shared and reused across multiple projects within a single repository.

## Features Overview

### Cluster Management
Easily manage multiple processes with the built-in Cluster module. Whether you’re scaling horizontally or running multiple worker threads, s42-core provides seamless clustering capabilities.

### Server-Sent Events (SSE)
s42-core simplifies the implementation of real-time communication with its Server-Sent Events (SSE) support. Push updates from the server to clients effortlessly, enabling real-time functionality in your applications.

### Event-Driven Architecture
With the EventsDomain class, s42-core allows you to implement a fully event-driven architecture. Microservices can emit and listen to domain events, fostering a decoupled and resilient system.

### SQLite and Redis Support
s42-core includes built-in support for SQLite and Redis, enabling fast and efficient data storage and caching solutions. It also simplifies interactions with these databases, so you can focus on your application’s logic.

### Dynamic Routing
The RouteControllers module provides dynamic routing capabilities, allowing you to create flexible and modular route configurations for your application.


## Use Cases

### Real-Time Applications
Leverage SSE to implement real-time features such as live notifications, dashboards, or chat applications.

### Event-Driven Systems
Build event-driven architectures where microservices communicate through domain events. For instance, emit an event when a user registers, and have another microservice listen for this event to send a welcome email.

### Modular Monorepos
With s42-core, you can structure your codebase as reusable components, promoting better collaboration and faster development cycles.

### Data-Intensive Applications
Effortlessly integrate SQLite and Redis for efficient data management, ensuring optimal performance for data-intensive operations.

## Getting Started

### Installation
To install s42-core, run:
```bash
bun add s42-core
```

## Usage Examples

### Using EventsDomain for Microservices Communication

The `EventsDomain` class enables seamless event-based communication between microservices. For example, you can use it to emit an event from a user registration service and listen to it in an email notification service.

```typescript
import { EventsDomain, RedisClient } from 's42-core';

const redisInstance = RedisClient.getInstance('redis://localhost:6379');
const eventsDomain = EventsDomain.getInstance(redisInstance, 'service-uuid');

// Emit an event
eventsDomain.emitEvent('user.registered', {
  email: 'example@example.com',
  name: 'John Doe',
});

// Listen to an event
eventsDomain.listenEvent('user.registered', (payload) => {
  console.info('User registered:', payload);
});
```

---

### Creating Controllers

Controllers handle HTTP requests and middleware. Here’s an example of creating a simple controller:

```typescript
import { Controller } from 's42-core';

const userController = new Controller('POST', '/users', async (req, res) => {
  const userData = req.body;
  console.info('User data received:', userData);
  res.json({ success: true, data: userData });
});
```

---

### Integrating Controllers with RouteControllers

RouteControllers organize and manage multiple controllers efficiently:

```typescript
import { RouteControllers, Controller } from 's42-core';

const healthController = new Controller('GET', '/health', async (req, res) => {
  res.text('OK');
});

const router = new RouteControllers([userController, healthController]);

// Use the router in your server
server.start({ RouteControllers: router });
```

---

### Server-Sent Events (SSE)

Easily implement real-time communication with the SSE class:

```typescript
import { SSE, Controller } from 's42-core';

const sseController = new Controller('GET', '/events', async (req) => {
  const sse = new SSE(req);
  setInterval(() => {
    sse.send({ eventName: 'time', eventPayload: { time: new Date().toISOString() } });
  }, 1000);
  return sse.getResponse();
});
```

---

### Cluster Management

The `Cluster` class simplifies worker process management:

```typescript
import { Cluster } from 's42-core';

const cluster = new Cluster({ name: 'example-cluster', maxCPU: 4, watch: true });

cluster.start('./worker.js', (error) => {
  if (error) console.error('Cluster failed:', error);
});

cluster.onWorkerMessage((message) => {
  console.info('Message from worker:', message);
});
```

---
For assistance, you can contact the author via Telegram or email:

- Telegram: [Contact](https://t.me/lortmorris)
- Email: cesar@stock42.com

Explore the [documentation](/en/reference) to learn more about leveraging the power of s42-core in your projects.

